#include <iostream>
#include <algorithm>
using namespace std;
#define MAX 101
int D[MAX][MAX];
int n;
int maxSum[MAX][MAX];//可以不用maxSum数组 
int main()
{
	int i,j;
	cin >> n;
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			cin >> D[i][j];
	//读入数据 
	for(int i=1;i<=n;i++)
		maxSum[n][i] = D[n][i];
	//复制最后一行 
	for(int i=n-1;i>=1;i--)//控制行 
		for(int j=1;j<=i;j++)//控制列 
			maxSum[i][j] = max(maxSum[i+1][j],maxSum[i+1][j+1]) + D[i][j]; 
	cout << maxSum[1][1] << endl;
}
/*递归到动规的一般转化方法
递归函数有n个参数,就定义一个n维的数组,数组的下标
是递归函数参数的取值范围，数组元素的值是递归函数
的返回值,这样就可以从边界值开始,逐步填充数组,相当
于计算递归函数值的逆过程*/

/*动规解题的一般思路 

1.将原问题分解为子问题
*把原问题分解为若干个子问题,子问题和原问题形式相同
或类似,只不过规模变小了,子问题都解决,原问题即解决
*子问题的解一旦求出就会被保存,所以每个子问题只需求
解一次
 
2.确定状态
*在用动态规划解题时,我们往往将和子问题相关的各个
变量的一组取值,称之为一个状态.一个状态对应于一个
或多个子问题,所谓某个状态下的值,就是这个状态所对
应的子问题的解 
*所有状态的集合,构成问题的状态空间,状态空间的大小
与用动态规划解决问题的时间复杂度直接相关.在数字三
角形的例子里,一共有N*(N+1)/2个数字,所有这个问题的
状态空间里一共就有N*(N+1)/2个状态
*整个问题的时间复杂度是状态数目乘以计算每个状态所
需的时间

3.确定一些边界状态的值 

4.确定状态转移方程
*定义出什么是"状态",以及在该状态下的值后，就要找出
不同的状态之间如何迁移--即如何从一个或多个值已知的
"状态",求出另一个"状态"的值("人人为我"递推型).状态
的迁移可以用递推共识表示,此递推公式也可被称作"状态
转移方程" 

数字三角形的状态转移方程:
MaxSum[r][i]=D[r][i]                                       r = N
             Max(MaxSum[r+1][j],MaxSum[r+1][j+1]+D[r][j]   其他情况 

能用动规解决的问题的特点
1.问题具有最优子结构性质.如果问题的最优解所包含的子
问题的解也是最优的,我们就称该问题具有最优子结构性质 
2.无后效性.当前的若干个状态值一旦确定,则此后过程的
演变就只和这若干个状态的值有关,和之前是采取哪种手段
或经过哪条路径演变到当前的这若干个状态,没有关系 

*/
